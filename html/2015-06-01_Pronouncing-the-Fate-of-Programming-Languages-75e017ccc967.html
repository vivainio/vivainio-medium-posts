<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Pronouncing the Fate of Programming Languages</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Pronouncing the Fate of Programming Languages</h1>
</header>
<section data-field="subtitle" class="p-summary">
I read way too much reddit and felt like writing down predictions on what will happen with various programming languages on the radar right…
</section>
<section data-field="body" class="e-content">
<section name="d509" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6dc9" id="6dc9" class="graf graf--h3 graf--leading graf--title">Pronouncing the Fate of Programming Languages</h3><p name="5cfa" id="5cfa" class="graf graf--p graf-after--h3">I read way too much reddit and felt like writing down predictions on what will happen with various programming languages on the radar right now. This is a bizarre mixture of of wishful thinking, personal delusion and realism; and as expected for the subject matter, not without a pinch of good old-fashioned trolling.</p><h3 name="f6e9" id="f6e9" class="graf graf--h3 graf-after--p">Java</h3><p name="a921" id="a921" class="graf graf--p graf-after--h3">Will continue to be hated by the masses, and will lag behind other programming languages by 5–10 years in features. Despite this, it will be widely used because it’s a fast, managed (safe) runtime that runs on Linux.</p><p name="a258" id="a258" class="graf graf--p graf-after--p">There is also good money to be made in Java consulting, so if you appreciate the Good Life with a degree of tolerance for professional garbage shoveling, Java offers tons of opportunities.</p><h3 name="afe1" id="afe1" class="graf graf--h3 graf-after--p">C#</h3><p name="f1af" id="f1af" class="graf graf--p graf-after--h3">Recent open sourcing and cross platform push will make it viable for “hot” startups in 2016. It will still lag behing Java, but it’s also moving much faster in terms of new feature development, so “cool kids” may discover it sooner rather than later (probably around the time Linux will become the first class deployment target and OSX a good development environment). It’s growing several modern features (tuple unpacking etc) and, unlike Java, already has a good array of nowadays-expected enablers like LINQ and local type inference.</p><h3 name="aff8" id="aff8" class="graf graf--h3 graf-after--p">Scala</h3><p name="b632" id="b632" class="graf graf--p graf-after--h3">Will slow down — it’s a in many ways “best in class” on JVM, but also considered too complex and various companies (like Linkedin) have been backpedaling on it. It’s also said to be significantly slower than Java (when written in the community-preferred functional style), and even Stroustrup has been taking jabs at how slow the compiler is.</p><h3 name="cd8c" id="cd8c" class="graf graf--h3 graf-after--p">Clojure</h3><p name="0cbc" id="0cbc" class="graf graf--p graf-after--h3">Will slow down. Lisp syntax is a showstopper for many programmers (not just junior developers), and lack of static typing will become a contraindication in larger projects. Like Ruby and Python, you will get “somewhere” quite fast, but scaling a dynamically typed macro-heavy code will become a mess. The selling points like immutable data or concurrency libraries are available elsewhere.</p><p name="ede6" id="ede6" class="graf graf--p graf-after--p">The language has energetic and vocal community, so it will keep popping up with some regularity. This should not be seen as indicative of its long-term mainstream appeal.</p><p name="25b7" id="25b7" class="graf graf--p graf-after--p">ClojureScript could be a promising exempt to this — the macro system could prove to be a good productivity boost for next generation javascript framework creation.</p><h3 name="068c" id="068c" class="graf graf--h3 graf-after--p">Haskell</h3><p name="57cb" id="57cb" class="graf graf--p graf-after--h3">Will continue to go nowhere. Unfamiliar runtime behavior (laziness), severe restrictions for “normal programming” (like local mutable variables and loops) and impenetrable academic jargon will keep it as a research language. Also, the M-word.</p><h3 name="1c18" id="1c18" class="graf graf--h3 graf-after--p">Node</h3><p name="b933" id="b933" class="graf graf--p graf-after--h3">Will continue it’s fast ascent. It has found good adoption regardless of it’s flaws (single threaded runtime, widely-disliked programming language and “callback hell”), but as the runtime and the programming language are being improved more rapidly (TypeScript, SoundScript, IO.js “takeover”, etc) it will be hard to stop — also, as far as dynamic languages go, it will be hard to rationalize Clojure over Node in greenfield (non-JVM) projects.</p><h3 name="105d" id="105d" class="graf graf--h3 graf-after--p">Python</h3><p name="912f" id="912f" class="graf graf--p graf-after--h3">Will retain it’s popularity, but won’t grow much. It already does very well the job it’s being used for, but its raw runtime performance will continue to lag behing the present competition (and runtime performance is the new hotness). “Batteries included” and simplicity will continue to find new fans. New gradual typing enchancements in Python 3 could breath new life to it in larger team efforts, but the (real or perceived) performance problems will make it a harder sell for new projects.</p><h3 name="98da" id="98da" class="graf graf--h3 graf-after--p">Ruby</h3><p name="caf3" id="caf3" class="graf graf--p graf-after--h3">Will decline. Hayday of Rails is over with new focus on REST(ish) api’s, so server side rendering (the forte’ of Rails) is already seen be a legacy technology. Ruby has several “killer applications” on the web development side, but, unlike Python, doesn’t have a strong foothold in scientific computing or system scripting. Like Python, it’s in the slower end of the language spectrum.</p><h3 name="9e8b" id="9e8b" class="graf graf--h3 graf-after--p">Perl</h3><p name="5e76" id="5e76" class="graf graf--p graf-after--h3">Is dead.</p><h3 name="c8f4" id="c8f4" class="graf graf--h3 graf-after--p">Go</h3><p name="d66f" id="d66f" class="graf graf--p graf-after--h3">Will continue it’s good growth. Programming language theorists abhor the weak type system (no generics), but it has “somehow sufficient” static type system, acceptable performance, well thought out standard library, good community and big deployment benefits (just drop the statically linked executable on your server), so it will become a well-liked language for command line apps and focused microservices (yes, the other M-word).</p><h3 name="8bc0" id="8bc0" class="graf graf--h3 graf-after--p">F#</h3><p name="c682" id="c682" class="graf graf--p graf-after--h3">I actually have no idea how well F# will fare, but I like the language a lot so wanted to add it to the list ;-). Due to new cross-platform drive for .NET, it has become newly viable; it also has several advanced features (like global type inference, dead-easy generics, appealing syntax and a strong type system) while remaining usable as a “normal” imperative programming language. It also benefits from good tooling support (read: visual studio), but unfortunately you are still stuck with Windows for best experience.</p><p name="6f21" id="6f21" class="graf graf--p graf-after--p">If you are a fan of dynamic languages and gravitate towards functional style (think short functions; list comprehensions; arrays, tuples and dicts instead of classes; generators), you can find yourself quite cozy with F#.</p><h3 name="7a65" id="7a65" class="graf graf--h3 graf-after--p">Visual Basic</h3><p name="314c" id="314c" class="graf graf--p graf-after--h3">Will continue to be used for applications that are not deemed worth porting to better-liked programming languages</p><h3 name="e145" id="e145" class="graf graf--h3 graf-after--p">Erlang</h3><p name="efec" id="efec" class="graf graf--p graf-after--h3">Is still being used, for reasons known only to Erlang users. Has a fancy runtime that can deal with restarting dead lightweight processes, but is locked to a bizarre programming language from the 70&#39;s for incomprehensible reasons.</p><h3 name="9a74" id="9a74" class="graf graf--h3 graf-after--p">C++</h3><p name="9a3b" id="9a3b" class="graf graf--p graf-after--h3">Will be used for AAA game development until ca. 2024. C++11 took some steps to make it more palatable to modern programming tastes (auto, lambdas), but the language itself has just grown too big and hard for new generation of programmers.</p><h3 name="ea50" id="ea50" class="graf graf--h3 graf-after--p">C</h3><p name="0a22" id="0a22" class="graf graf--p graf-after--h3">Will be replaced by Rust once developers realize how unsafe and vulnerable their C applications are. High Priesthood of programmers, IOW kernel developers, will stick to it forever.</p><h3 name="044a" id="044a" class="graf graf--h3 graf-after--p">PHP</h3><p name="86e9" id="86e9" class="graf graf--p graf-after--h3">Enough has been said about PHP. It won’t go away even if you don’t pay attention to it, but if you keep your skills sharp you should be able to avoid PHP-related jobs even in current economy.</p><h3 name="6def" id="6def" class="graf graf--h3 graf-after--p">Objective-C</h3><p name="c554" id="c554" class="graf graf--p graf-after--h3">Will be phased out in favor of Swift once Cook finally &amp; unilaterally pulls the plug.</p><h3 name="a927" id="a927" class="graf graf--h3 graf-after--p">Rust</h3><p name="1df2" id="1df2" class="graf graf--p graf-after--h3">Will grow as a safer alternative C and, to some extent, C++. Most programmers don’t need full control of memory allocation (maximization of stack usage, using heap as little as possble) and absolutely predictable performance, but Rust delivers this along with a lot of modern conveniences (pattern matching, destructuring) and an NPM-like package ecosystem through creates.io.</p><h3 name="7f46" id="7f46" class="graf graf--h3 graf-after--p">Dart</h3><p name="e0bc" id="e0bc" class="graf graf--p graf-after--h3">Offers no tangible benefits over TypeScript (especially after the introduction of Google’s “SoundScript” (repeat after me, it’s not called “SaneScript” anymore as a manner of professional courtesy), and the development will be gradually ramped down to “community effort”</p><h3 name="1cda" id="1cda" class="graf graf--h3 graf-after--p">TypeScript</h3><p name="edbd" id="edbd" class="graf graf--p graf-after--h3">Will continue to be shunned by ES6-purists for emotional reasons, but in the meantime it will be successfully used in big projects to get real work done. Will disappear once ES20XX gain a type system that is exactly as implemented in TypeScript. Once browsers grow ES7 support, they will ignore the type annotations so a transpiler (as opposed to development time type checker) won’t be needed anymore.</p><h3 name="117d" id="117d" class="graf graf--h3 graf-after--p">OCaml</h3><p name="3be6" id="3be6" class="graf graf--p graf-after--h3 graf--trailing">Had a chance to be the “Go” language several years ago, but it didn’t pan out. Legacy lives on in F# and Rust.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@vivainio" class="p-author h-card">Ville M. Vainio</a> on <a href="https://medium.com/p/75e017ccc967"><time class="dt-published" datetime="2015-06-01T21:39:21.376Z">June 1, 2015</time></a>.</p><p><a href="https://medium.com/@vivainio/pronouncing-the-fate-of-programming-languages-75e017ccc967" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 1, 2019.</p></footer></article></body></html>