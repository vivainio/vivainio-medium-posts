<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>MobX with Angular, Part 2: Patterns, Perks and Gotchas</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">MobX with Angular, Part 2: Patterns, Perks and Gotchas</h1>
</header>
<section data-field="subtitle" class="p-summary">
This is the second installation of the critically acclaimed “MobX with Angular” series. If you came here googling for “ngrx alternatives…
</section>
<section data-field="body" class="e-content">
<section name="d756" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2be1" id="2be1" class="graf graf--h3 graf--leading graf--title">MobX with Angular, Part 2: Patterns, Perks and Gotchas</h3><figure name="8cbd" id="8cbd" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 1023px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 146.2%;"></div><img class="graf-image" data-image-id="1*NxzzwQj3ffG0jugGdFrP2w.jpeg" data-width="760" data-height="1111" src="https://cdn-images-1.medium.com/max/800/1*NxzzwQj3ffG0jugGdFrP2w.jpeg"></div><figcaption class="imageCaption">State management shouldn’t be rocket science</figcaption></figure><p name="94b0" id="94b0" class="graf graf--p graf-after--figure">This is the second installation of the critically acclaimed “MobX with Angular” series. If you came here googling for “ngrx alternatives sweet jesus make it stop”, you are in the right place. You probably want to read <a href="https://medium.com/@vivainio/mobx-with-angular-the-prelude-1c0dcfb43fe6" data-href="https://medium.com/@vivainio/mobx-with-angular-the-prelude-1c0dcfb43fe6" class="markup--anchor markup--p-anchor" target="_blank">part 1</a> for the basics (or any generic React-oriented MobX tutorial if you don’t particularly like my writing).</p><p name="49e3" id="49e3" class="graf graf--p graf-after--p">On to the non-basics. We are creating a big Angular application with a largish, geographically distributed team at <a href="https://www.basware.com/" data-href="https://www.basware.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Basware</a>, and have established this as a pretty workable design (for the purposes of discussion I’m using the classical Blog Post feature as the example):</p><ul class="postList"><li name="e4d1" id="e4d1" class="graf graf--li graf-after--p">The single source of truth is the Store, <em class="markup--em markup--li-em">posts.store.ts</em> (class <em class="markup--em markup--li-em">PostsStore</em>). It contains the @observable properties, and all the @action’s that modify the state.</li><li name="cb0a" id="cb0a" class="graf graf--li graf-after--li">There are many Stores. You could have <em class="markup--em markup--li-em">AuthorsStore</em>, <em class="markup--em markup--li-em">SettingsStore </em>etc.</li><li name="4ab3" id="4ab3" class="graf graf--li graf-after--li">Components don’t access (i.e. inject) the Store directly. Instead, they use a facade called <em class="markup--em markup--li-em">PostsService</em>, in <em class="markup--em markup--li-em">posts.service.ts</em>.</li><li name="d7a2" id="d7a2" class="graf graf--li graf-after--li">Http requests are done by <em class="markup--em markup--li-em">PostsApiService</em>, in <em class="markup--em markup--li-em">posts.api.ts</em>. This is the only place that knows what url’s are used. This is also a good place to put a breakpoint when wondering why on earth that one request was sent three times.</li></ul><h4 name="4854" id="4854" class="graf graf--h4 graf-after--li">The Facade</h4><p name="47cc" id="47cc" class="graf graf--p graf-after--h4"><em class="markup--em markup--p-em">PostsService </em>is responsible for exposing parts of the Store to the components. That is, it’s what your <em class="markup--em markup--p-em">post-reader.component.ts</em> injects to do stuff.</p><p name="322a" id="322a" class="graf graf--p graf-after--p">If there is asynchronous http work to do, <em class="markup--em markup--p-em">PostsService</em> calls to <em class="markup--em markup--p-em">posts.api.ts</em> service (<em class="markup--em markup--p-em">PostsApiService</em>) that sends the request. <em class="markup--em markup--p-em">PostsService </em>then captures the response and updates the state accordingly (usually calling an action in Store). Here’s an example flow:</p><ol class="postList"><li name="510b" id="510b" class="graf graf--li graf-after--p">User clicks a post. Component calls <em class="markup--em markup--li-em">postsService.documentChanged(id) </em>which is a hint that we want the data for that document.</li><li name="ef0b" id="ef0b" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">PostService </em>notices that we don’t have that document in store. It triggers the fetch knowing it’s needed soon.</li><li name="77c3" id="77c3" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">PostsReaderComponent </em>is observing <em class="markup--em markup--li-em">postService.getPost(id)</em>. It keeps returning <em class="markup--em markup--li-em">undefined </em>(or <em class="markup--em markup--li-em">null </em>if you are so inclined) for now. A busy spinner is spinning.</li><li name="8549" id="8549" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">PostService </em>finally receives the post content. It calls the action <em class="markup--em markup--li-em">store.setPost(id, { content: “blah blah”})</em></li><li name="24e7" id="24e7" class="graf graf--li graf-after--li">The observer of <em class="markup--em markup--li-em">getPost(id)</em> is woken up now that the data changed, and it can place the content in a component instance variable. This dismisses the spinner and reveals the glorious post content.</li></ol><p name="f17b" id="f17b" class="graf graf--p graf-after--li">It’s worth mentioning that MobX itself has support for async workflows, through <a href="https://mobx.js.org/best/actions.html" data-href="https://mobx.js.org/best/actions.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">async actions and flow()</a>. We are not using those because</p><ul class="postList"><li name="6b90" id="6b90" class="graf graf--li graf-after--p">we want to stick with relatively tried-and-true async patterns familiar from AngularJS 1.x days</li><li name="5f26" id="5f26" class="graf graf--li graf-after--li">generators don’t work great (read: hardly at all) with current crop of debuggers and source maps</li><li name="9f8e" id="9f8e" class="graf graf--li graf-after--li">async is not exactly rocket science. Every action on the store is a dumb, instant “commit”.</li></ul><h4 name="d267" id="d267" class="graf graf--h4 graf-after--li">createTransformer()</h4><p name="eb2a" id="eb2a" class="graf graf--p graf-after--h4">You noticed the <em class="markup--em markup--p-em">postService.getPost(id)</em> above. It will probably look for the content in an observable <em class="markup--em markup--p-em">Map&lt;string, PostData&gt;</em>. You can call it in autorun body just fine, but there is actually a better and faster way.</p><p name="2eba" id="2eba" class="graf graf--p graf-after--p">Usually, MobX recommends doing most calculations in <em class="markup--em markup--p-em">@computed</em> properties instead of complex <em class="markup--em markup--p-em">autorun </em>bodies when you can:</p><ul class="postList"><li name="a2c2" id="a2c2" class="graf graf--li graf-after--p">It’s faster. When a computed property is observed, it is “hot”. That is, when the data or other computed properties are modified, the computed values are pushed out and memoized. Just calling the computed property will get you the memoized value. If there are many components observing the same data in autoruns, they will be recalculated every time the data changes. With computed properties, the calculation is run only once. This means you can safely call them without worrying about performance under the hood.</li><li name="4bf8" id="4bf8" class="graf graf--li graf-after--li">They are a cleaner programming pattern. When you see something is computed, you know it’s just a pure projection of underlying state. And, you know you should be observing that state in the top level autorun() somewhere. Non-computed things could be doing anything else. You’ll probably implement your state by having a whole tree of projections refining and improving the state to fit your particular consumption needs.</li></ul><p name="8da7" id="8da7" class="graf graf--p graf-after--li">Now that I convinced you of their merits, here comes the Gotcha 1: <strong class="markup--strong markup--p-strong">you can’t pass arguments to computed functions</strong>. They are just getters with no arguments. You could just have “<em class="markup--em markup--p-em">currentPostId</em>” in store, and give data for that current post in the computed getters. But, this won’t work if you have multiple posts being observed at the same time (say, you have a two pane post reader showing different posts at the same time).</p><p name="2e76" id="2e76" class="graf graf--p graf-after--p">This is where <a href="https://mobx.js.org/refguide/create-transformer.html" data-href="https://mobx.js.org/refguide/create-transformer.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">createTransformer() in mobx-utils </a>steps in (if you understood none of the official description, read on). Here we create a <em class="markup--em markup--p-em">getPostAndAuthorData </em>(in <em class="markup--em markup--p-em">PostsService </em>class body) that reads stuff from two different transformers (projections):</p><figure name="a171" id="a171" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vivainio/2283d073d0a17fac58f83dd20fe31ff2.js"></script></figure><p name="b095" id="b095" class="graf graf--p graf-after--figure">The call to <em class="markup--em markup--p-em">getPostAndAuthorData</em>() discovers the internal computation by looking it up by the <em class="markup--em markup--p-em">postId</em>. You can only pass one primitive argument to the transformation, but I know that you, Dear Reader, will usually be using a string <em class="markup--em markup--p-em">documentId </em>or somesuch. If you would need something more complex, eat it up and use <em class="markup--em markup--p-em">autorun</em>() instead.</p><h4 name="cd94" id="cd94" class="graf graf--h4 graf-after--p">Component code</h4><p name="7e73" id="7e73" class="graf graf--p graf-after--h4">In the end, you’ve got to be observing the data in autorun, otherwise it’ll all be for naught. For our application, we have made a utility to</p><ol class="postList"><li name="bd47" id="bd47" class="graf graf--li graf-after--p">Create a list of autoruns.</li><li name="b490" id="b490" class="graf graf--li graf-after--li">Dispose them in ngOnDestroy().</li></ol><p name="aeec" id="aeec" class="graf graf--p graf-after--li">It’s used like this:</p><figure name="4dfb" id="4dfb" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vivainio/35749c7e33796fb81e80edcde5633861.js"></script></figure><p name="ce85" id="ce85" class="graf graf--p graf-after--figure">The strings in there are names of the observables, so <a href="https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod?hl=en" data-href="https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod?hl=en" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">mobx-devtools</a> Chrome plugin (that also works with Angular) shows them nicely. You can grab the utilities (<em class="markup--em markup--p-em">startObservers</em>, <em class="markup--em markup--p-em">addComponentDisposer </em>and <em class="markup--em markup--p-em">stopObserving</em>) from <a href="https://github.com/vivainio/angularpack/blob/master/src/mobtool.ts" data-href="https://github.com/vivainio/angularpack/blob/master/src/mobtool.ts" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Github</a>. The first argument to <em class="markup--em markup--p-em">startObservers</em>() is optional; if you pass the component <em class="markup--em markup--p-em">ChangeDetectorRef </em>there, triggering any of the listed observers will also run change detection on that component. This is usually needed for OnPush components.</p><p name="1bda" id="1bda" class="graf graf--p graf-after--p">Why not shove everything in one autorun? The basic idea is to segregate them so that only the part that depends on a particular change is run when needed.</p><p name="128d" id="128d" class="graf graf--p graf-after--p">Natural place to “start observing” is <em class="markup--em markup--p-em">ngOnInit</em>(), since that is only run once per component, and the components input attributes have settled by the time it runs. You can delay the initialization of observables by MobX <em class="markup--em markup--p-em">when()</em> function that retuns a promise that resolves when the observed expression returns true:</p><figure name="5e65" id="5e65" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vivainio/548e7ace6fce6f0b4bf1a2bacd3ac5de.js"></script></figure><h4 name="2541" id="2541" class="graf graf--h4 graf-after--figure">There is no such thing as free lunch</h4><p name="3033" id="3033" class="graf graf--p graf-after--h4">With all this magic and rainbows, there’s got to be a price to pay, right? Well, there is, and sooner you know the better:</p><ul class="postList"><li name="562d" id="562d" class="graf graf--li graf-after--p">Decorators like @observable and @computed can’t currently (as of Angular 5) be used in components because AoT compiler chokes up on them. <em class="markup--em markup--li-em">createTransformer</em>(), on the other hand, can be used, and can be handy for some marginal refinement you want to do at the edges. MobX 4 provides an alternative syntax using <em class="markup--em markup--li-em">declare(),</em> which won’t trigger this problem.</li><li name="d15e" id="d15e" class="graf graf--li graf-after--li">The observable data in stores is injected with MobX specific metadata, and the attributes of objects are transformed to getters/setters. This means you need to click individual properties in the debugger to investigate them.</li><li name="1dd5" id="1dd5" class="graf graf--li graf-after--li">Observable arrays look bad in the debugger. You will see hundreds of items per array, and need to click through the items to even see the length. Upcoming MobX 5 will fix this (by using ES6 proxies).</li><li name="60ae" id="60ae" class="graf graf--li graf-after--li">Some JavaScript libraries can when fail dealing with observable data structures. E.g. lodash <em class="markup--em markup--li-em">_.flatMap</em> (which is lodash version of <em class="markup--em markup--li-em">smooshMap()</em>) just fails to deliver with an observable array. To be fair, that’s the only bad lodash function that I know of, so no need to throw out lodash quite yet.</li></ul><p name="3083" id="3083" class="graf graf--p graf-after--li">The last three problems above can be avoided by using toJS() in your computeds/transformers/autoruns — so you won’t see the guts of observable data structures at the edges. You can also log stuff to console through toJS():</p><figure name="db5c" id="db5c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vivainio/cf21b5915803589cb6832e1e0a78b8ef.js"></script></figure><p name="63b2" id="63b2" class="graf graf--p graf-after--figure">All that being said, the debugger experience with MobX is very good. If you set a breakpoint in autorun or computed property, you see precisely what triggered the change from the call stack — and the call stack fits on the screen, as opposed to anything involving RxJS observables.</p><h4 name="cb10" id="cb10" class="graf graf--h4 graf-after--p">Should you still be using RxJS?</h4><p name="d56d" id="d56d" class="graf graf--p graf-after--h4">A good rule of thumb is: not as much as you did.</p><ul class="postList"><li name="d546" id="d546" class="graf graf--li graf-after--p">For dumb components that don’t want to take dependency to any kind of store, pass immutable objects as inputs, and reassign the value to trigger component update (for OnPush components).</li><li name="a3ac" id="a3ac" class="graf graf--li graf-after--li">Sometimes you have scenarios where component needs notification for events (as opposed to changing state as pure function of data in store — something you should do most of the time). Creating a <em class="markup--em markup--li-em">BehaviorSubject&lt;SomeSpecialEvent&gt;</em> in a service provided at component level is fine for that. The alternative of passing <em class="markup--em markup--li-em">@Output</em> events through every level can get cumbersome. Real life example: we are broadcasting events from ag-grid through a <em class="markup--em markup--li-em">BehaviorSubject</em> for the components above.</li><li name="6e5a" id="6e5a" class="graf graf--li graf-after--li graf--trailing">Methods in your http api services (e.g. <em class="markup--em markup--li-em">PostsApiService</em>) usually start the <em class="markup--em markup--li-em">HttpClient </em>observable and <em class="markup--em markup--li-em">map()</em> it a bit to mungle the data. If the logic gets complex enough to not be readily readable using RxJS (e.g. once you go beyond trivial <em class="markup--em markup--li-em">map()</em>), you shouldn’t be shy to run <em class="markup--em markup--li-em">.toPromise()</em> on the observable and use async/await. Your pull request reviewers will thank you for it.</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@vivainio" class="p-author h-card">Ville M. Vainio</a> on <a href="https://medium.com/p/37e2a393e0eb"><time class="dt-published" datetime="2018-04-30T20:07:13.337Z">April 30, 2018</time></a>.</p><p><a href="https://medium.com/@vivainio/mobx-with-angular-part-2-patterns-perks-and-gotchas-37e2a393e0eb" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 1, 2019.</p></footer></article></body></html>